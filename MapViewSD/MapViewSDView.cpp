//
//	MapViewSDView.cpp - implementation of the CMapViewSDView class (generated by Visual Studio)
//  Copyright(C) 2024 Michael E. Cressey
//
//	This program is free software : you can redistribute it and /or modify it under the terms of the
//	GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or
//	any later version.
//
//	This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
//	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License along with this program.
//  If not, see https://www.gnu.org/licenses/
//

#include "pch.h"
#include "stdlib.h"
#include "framework.h"
// SHARED_HANDLERS can be defined in an ATL project implementing preview, thumbnail
// and search filter handlers and allows sharing of document code with that project.
#ifndef SHARED_HANDLERS
#include "MapViewSD.h"
#endif
#include "mapviewSD.h"
#include "MainFrm.h"
#include "MapViewSDDoc.h"
#include "MapViewSDView.h"

#include "dbsearch.hpp"
#include "lineseg.hpp"
#include "drawline.hpp"
#include "mappdial.h"
#include "thindlg.h"
#include "trendlin.h"
#include "SearchUserID.h"
#include "HASHTABL.HPP"
#include "ShortPath.h"
#include "TopoTools.h"
#include <vector>
#include <algorithm>
#include "TString.h"
#include <assert.h>

#define DO_SHORT_PATH

using namespace NodeEdgePoly;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMapViewSDView

IMPLEMENT_DYNCREATE(CMapViewSDView, CView)

BEGIN_MESSAGE_MAP(CMapViewSDView, CView)
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CMapViewSDView::OnFilePrintPreview)
	ON_WM_CONTEXTMENU()
	ON_WM_RBUTTONUP()
	ON_COMMAND(ID_ZOOM_IN, OnZoomIn)
	ON_COMMAND(ID_ZOOM_OUT, OnZoomOut)
	ON_COMMAND(ID_ZOOM_DOWN, OnPanDown)
	ON_COMMAND(ID_ZOOM_LEFT, OnPanLeft)
	ON_COMMAND(ID_ZOOM_RIGHT, OnPanRight)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_COMMAND(ID_ZOOM_UP, OnPanUp)
	ON_COMMAND(ID_MAP_LAYERS, OnMapLayers)
	ON_UPDATE_COMMAND_UI(ID_MAP_LAYERS, OnUpdateMapLayers)
	ON_COMMAND(ID_VIEW_LINEINFO, OnLineInfo)
	ON_UPDATE_COMMAND_UI(ID_VIEW_LINEINFO, OnUpdateLineInfo)
	ON_COMMAND(ID_MAP_PROJECTION, OnMapProj)
	ON_COMMAND(ID_MAP_THINING, OnThinPts)
	ON_COMMAND(ID_SEARCH_USERID, OnSearchUserid)
	ON_UPDATE_COMMAND_UI(ID_SEARCH_USERID, &CMapViewSDView::OnUpdateSearchUserid)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_SHORTPATH, &CMapViewSDView::OnUpdateToolsShortpath)
	ON_COMMAND(ID_TOOLS_SHORTPATH, &CMapViewSDView::OnToolsShortpath)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_THINING, &CMapViewSDView::OnUpdateToolsThining)
	ON_COMMAND(ID_TOOLS_THINING, &CMapViewSDView::OnToolsThining)
END_MESSAGE_MAP()

static const char* LineStr(int code);
static const char* FeatureStr(int code);

// CMapViewSDView construction/destruction
enum LineDisplayTypes
{
	INTERSTATE_ROAD = 0,
	PRIMARY_ROAD,
	SECONDARY_ROAD,
	LOCAL_ROAD,
	SHORELINE,
	STREAM,
	TRAIL,
	BOUNDARY,
	PARK,
	OTHER_ROAD,
	OTHER
};

const int BLCK_PEN = 1;
const int RED_PEN = 0;
const int GREEN_PEN = 7;
const int BLUE_PEN = 3;
const int YELLOW_PEN = 4;		// RGB(255,255,0)
const int CYAN_PEN = 5;		// RGB(0,255,255)
const int MAGENTA_PEN = 8;		// RGB(255,0,255)
const int DASH_PEN = OTHER_ROAD + 1;
const int DOT_PEN = 8;
const int DASH_DOT_PEN = DASH_PEN + 1;
const int DASH_2DOTS_PEN = 12;

CMapViewSDView::CMapViewSDView() noexcept
{
	this->layerDlg = new LayerDlg(this);
	this->doThining = FALSE;
	this->doProj = 0;
	this->mapWin = 0;
	this->pens[INTERSTATE_ROAD].CreatePen(PS_SOLID, 2, RGB(0, 0, 255));
	this->pens[PRIMARY_ROAD].CreatePen(PS_SOLID, 2, RGB(255, 0, 0));
	this->pens[SECONDARY_ROAD].CreatePen(PS_SOLID, 2, RGB(0, 0, 0));
	this->pens[LOCAL_ROAD].CreatePen(PS_SOLID, 1, RGB(255, 0, 255));
	this->pens[SHORELINE].CreatePen(PS_SOLID, 1, RGB(0, 0, 255));
	this->pens[STREAM].CreatePen(PS_SOLID/*PS_DASHDOTDOT*/, 1, RGB(115, 223, 255)/*RGB(0, 255, 255)*/);
	this->pens[TRAIL].CreatePen(PS_DOT, 1, RGB(0, 0, 0));
	this->pens[BOUNDARY].CreatePen(PS_DASH, 1, RGB(230, 230, 0)/*RGB(255, 0, 0)*/);	// Citroen Yellow
	this->pens[PARK].CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
	this->pens[OTHER_ROAD].CreatePen(PS_SOLID, 1, RGB(255, 255, 0));
	this->pens[DASH_PEN].CreatePen(PS_DASH, 1, RGB(255, 0, 255));
	this->pens[DASH_DOT_PEN].CreatePen(PS_DASHDOT, 1, RGB(255, 0, 255));
	this->pens[DASH_2DOTS_PEN].CreatePen(PS_DASHDOTDOT, 1, RGB(255, 0, 255));

	this->hydroBrush.CreateSolidBrush(RGB(0, 145, 255)/*RGB(27, 149, 224)*/);
	this->parkBrush.CreateSolidBrush(RGB(85, 255, 0)/*RGB(0, 255, 0)*RGB(27, 149, 224)*/);	// ESRI Medium Apple
	this->isleBrush.CreateSolidBrush(RGB(205, 170, 102)/*RGB(168, 112, 0)*/);		// ESRI Light Sienna
	
	pts = 0;
	this->pan_overlap = 50;
	this->zoom_factor = 2.0;
	this->sDist = .001;
	this->tDist = 0.0;
	this->pts = 0;
	this->doWindow = FALSE;
	this->doPick = FALSE;
	this->doInfo = FALSE;

	this->pen.CreatePen(PS_SOLID, 1, RGB(255, 255, 255));
	this->hPen.CreatePen(PS_SOLID, 3, RGB(255, 0, 0));

	this->mapProj = 0;
	this->lineDlg = 0;

	GeoSphere sphere(6378.137);
	GeoEllipsoid ellipsoid;

	this->mapProjs[0] = new EquidistantCylindrical(sphere);
	this->mapProjs[1] = new TransverseMeracator(ellipsoid);
	this->lineDlg = 0;
	this->doTest = FALSE;
	this->doShortPath = FALSE;
	this->pickCount = 0;
	this->startId = 0;
	this->startDir = 0;
	this->startDist = 0.0;

	VERIFY(font.CreateFont(
		16,                       // nHeight
		0,                        // nWidth
		0,                        // nEscapement
		0,                        // nOrientation
		FW_NORMAL,                // nWeight
		FALSE,                    // bItalic
		FALSE,                    // bUnderline
		0,                        // cStrikeOut
		ANSI_CHARSET,             // nCharSet
		OUT_DEFAULT_PRECIS,       // nOutPrecision
		CLIP_DEFAULT_PRECIS,      // nClipPrecision
		DEFAULT_QUALITY,          // nQuality
		DEFAULT_PITCH | FF_SWISS, // nPitchAndFamily
		_T("Arial")));
}

CMapViewSDView::~CMapViewSDView()
{
	delete this->layerDlg;
	if (this->mapWin)
		delete this->mapWin;

	delete this->mapProj;

	if (this->pts)
		delete[] pts;

	for (int i = 0; i < sizeof(this->pens) / sizeof(this->pens[0]); i++)
		this->pens[i].DeleteObject();

	this->pen.DeleteObject();
	this->hPen.DeleteObject();
	if (this->lineDlg)
		delete this->lineDlg;
}

BOOL CMapViewSDView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

void CMapViewSDView::OnInitialUpdate()
{
	//	CSize region( 1, 1 );
	CView::OnInitialUpdate();
	CMapViewSDDoc* pDoc = GetDocument();

	ASSERT_VALID(pDoc);
	ASSERT(pDoc != NULL);
	ASSERT(pDoc->db != 0);
	if (!pDoc->isOpen)
		//  if( ! pDoc->db->IsOpen() )
		return;

	if (this->mapWin == 0)
	{
		this->mapWin = new MapWindow(0, 1);
		ASSERT(this->mapWin != 0);
		if (this->doProj != 0)
			this->mapWin->Set(this->mapProj);
	}

	this->lineDlg = new LineDlg(this);

	if (this->pts == 0)
		this->pts = new XY_t[15000];
	ASSERT(this->pts != 0);

	CRect region;
	GetClientRect(region);

	Range2D range;

	range.x.min = (double)region.left;
	range.x.max = (double)region.right;
	range.y.min = (double)region.top;
	range.y.max = (double)region.bottom;

	this->mapWin->SetViewport(range);

#ifdef SAVE_FOR_NOW
	if (this->mapProj)
	{
		XY_t ll,
			ur,
			center;

		pDoc->range.Corners(&ll, &ur);
		pDoc->range.Center(&center);
		this->mapProj->Set(center.x, center.y);

		this->mapProj->Forward(&ll, ll);
		this->mapProj->Forward(&ur, ur);
		range.Init(ll, ur);
		this->mapWin->Set(range);
		this->sDist = (range.x.max - range.x.min) / 100.0;
	}
	else
#endif
	{
		this->mapWin->Set(pDoc->range);
		if (this->mapProj)
		{
			XY_t center;

			pDoc->range.Center(&center);
			this->mapProj->Forward(&center, center);
			this->mapProj->Set(center.x, center.y);
		}
	}
	//	SetScrollSizes( MM_TEXT, region /*GetDocument()->GetDocSize()*/ );
	//	this->SetWindowText( GetDocument()->title );
}


// CMapViewSDView drawing
CBrush* CMapViewSDView::GetBrush(int code)	// Use for polygons
{
	if (!this->layerDlg->doAreas)
		return 0;
	
	switch (code)
	{
	default:
		break;

	case TigerDB::HYDRO_PerennialLakeOrPond :
	case TigerDB::HYDRO_SeaOrOcean:
		return &this->hydroBrush;

	case TigerDB::LM_StateOrLocalPark_Forest:
	case TigerDB::LM_NationalParkService:
	case TigerDB::LM_NationalForestOrOther:
		return &this->parkBrush;
	}

	return 0;
}

CPen* CMapViewSDView::GetPen(int code)		// Used for edges
{
	CPen* pen = 0;
	if (!this->layerDlg->doLines)
		return pen;

	switch (code)
	{
	default:
		// pen = &this->pens[DASH_2DOTS_PEN];
		break;

	case TigerDB::ROAD_MajorCategoryUnknown:
	case TigerDB::ROAD_SpecialCharacteristics:
	case TigerDB::ROAD_Cul_de_sac:
	case TigerDB::ROAD_TrafficCircle:
	case TigerDB::ROAD_AccessRamp:
	case TigerDB::ROAD_ServiceDrive:
	case TigerDB::ROAD_FerryCrossing:
	case TigerDB::ROAD_OtherThoroughfare:
		if (this->layerDlg->doOtherRds)
			pen = &this->pens[OTHER_ROAD];
		break;

	case TigerDB::ROAD_PrimaryLimitedAccess:
		if (this->layerDlg->doPrimaryRds)
			pen = &this->pens[INTERSTATE_ROAD];
		break;

	case TigerDB::ROAD_PrimaryUnlimitedAccess:
		if (this->layerDlg->doPrimaryRds)
			pen = &this->pens[PRIMARY_ROAD];
		break;

	case TigerDB::ROAD_SecondaryAndConnecting:
		if (this->layerDlg->doSecondaryRds)
			pen = &this->pens[SECONDARY_ROAD];
		break;

	case TigerDB::ROAD_LocalNeighborhoodAndRural:
		if (this->layerDlg->doLocalRds)
			pen = &this->pens[LOCAL_ROAD];
		break;

	case TigerDB::ROAD_VehicularTrail:
		if (this->layerDlg->doTrails)
			pen = &this->pens[TRAIL];
		break;

	case TigerDB::RR_MajorCategoryUnknown:
	case TigerDB::RR_MainLine:
	case TigerDB::RR_Spur:
	case TigerDB::RR_Yard:
	case TigerDB::RR_FerryCrossing:
	case TigerDB::RR_OtherThoroughfare:
		pen = 0;
		break;

	case TigerDB::MGT_CategoryUnknown:
	case TigerDB::MGT_Pipeline:
	case TigerDB::MGT_PowerLine:
	case TigerDB::MGT_Other:
		if (this->layerDlg->doGroundTransportation)
			pen = &this->pens[DASH_DOT_PEN];
		break;

	case TigerDB::LM_Airport:
	case TigerDB::LM_GolfCourse:
	case TigerDB::LM_Cemetery:
	case TigerDB::LM_NationalParkService:
	case TigerDB::LM_NationalForestOrOther:
	case TigerDB::LM_StateOrLocalPark_Forest:
		pen = &this->pens[PARK];
		break;

	case TigerDB::NVF_BoundaryClassificationUnknown:
	case TigerDB::NVF_LegalOrAdministrativeBoundary:
		if (this->layerDlg->doBoundary)
			pen = &this->pens[BOUNDARY];
		break;

	case TigerDB::NVF_PropertyLine:
	case TigerDB::HYDRO_CensusWaterCenterLine:
	case TigerDB::HYDRO_ArtificialPath:
		if (this->layerDlg->doOtherFeatures)
			pen = &this->pens[PARK];
		break;

	case TigerDB::HYDRO_ClassificationUnknown:
	case TigerDB::HYDRO_PerennialShoreline:
	case TigerDB::HYDRO_IntermittentShoreline:
	case TigerDB::HYDRO_IntermittentCanalDitchOrAqueduct:
	case TigerDB::HYDRO_PerennialLakeOrPond:
	case TigerDB::HYDRO_IntermittentLakeOrPond:
	case TigerDB::HYDRO_PerennialReservoir:
	case TigerDB::HYDRO_IntermittentReservoir:
	case TigerDB::HYDRO_BayEstuaryGulfOrSound:
	case TigerDB::HYDRO_SeaOrOcean:
	case TigerDB::HYDRO_GravelPitOrQuarry:
	case TigerDB::HYDRO_Glacier:
		if (this->layerDlg->doShoreline)
			pen = &this->pens[SHORELINE];
		break;

	case TigerDB::HYDRO_PerennialStream:
	case TigerDB::HYDRO_IntermittentStream:
		if (this->layerDlg->doStreams)
			pen = &this->pens[STREAM];
		break;
	}

	return(pen);
}

struct PolySort {
	double area;
	DbObject::Id id;
};

struct greater_than_key
{
	inline bool operator() (const PolySort& lhs, const PolySort& rhs)
	{
		return (lhs.area > rhs.area);
	}
};

bool CMapViewSDView::filter(GeoDB::SpatialObj* so)
{
	if (so->IsA() != GeoDB::LINE)
		return false;
	GeoDB::Edge* edge = (GeoDB::Edge*)so;
	return this->GetPen(edge->userCode) != 0;
}

void CMapViewSDView::OnDraw(CDC* pDC)
{
	CMapViewSDDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	CMainFrame* frame = (CMainFrame*)AfxGetApp()->m_pMainWnd;

	HCURSOR cursor = SetCursor(LoadCursor(0, IDC_WAIT));

	ASSERT(pDoc->db != 0);
	if (pDoc->isOpen)
	{
		Range2D range;
		CPen* lastPen = 0;
		CPen* oldPen = pDC->SelectObject((CPen*)pDC->SelectStockObject(NULL_PEN));
		//	CWinApp *app = AfxGetApp();

		{
			CRect region;
			XY_t pt1,
				pt2;

			pDC->GetClipBox(region);

			CPoint& pt = region.TopLeft();
			pt1.x = (double)pt.x;
			pt1.y = (double)pt.y;
			this->mapWin->Reverse(&pt1, pt1);
			pt = region.BottomRight();
			pt2.x = (double)pt.x;
			pt2.y = (double)pt.y;
			this->mapWin->Reverse(&pt2, pt2);

			range.Init(pt1, pt2);
		}

		//	app->LoadStandardCursor( IDC_WAIT );
		ObjHandle dbo;
		GeoDB::Search ss;
		int nLines = 0;

//		pDoc->db->CheckTree();

		// Polygons need to be displayed first because they are solid features.
		GeoDB::searchClasses_t polyClass;
		if (this->layerDlg->objClasses.test(DB_POLY))
		{
			std::vector<PolySort> polys;
			polyClass.set(DB_POLY);
			pDoc->db->InitSearch(&ss, range, polyClass);
			ObjHandle po;
			while (pDoc->db->getNext(&ss, &po) == 0)
			{
				GeoDB::SpatialObj* spatialObj = (GeoDB::SpatialObj*)po.Lock();
				GeoDB::SpatialClass sc = spatialObj->IsA();
				assert(sc == GeoDB::AREA);
				GeoDB::Poly* poly = (GeoDB::Poly*)spatialObj;

				PolySort ps;
				ps.area = poly->getArea();
				ps.id = poly->dbAddress();
				polys.push_back(ps);

				po.Unlock();
			}

			// Polygons need to be displayed in order of largest area first
			std::sort(polys.begin(), polys.end(), greater_than_key());
			for (int i = 0; i < polys.size(); i++)
			{
				PolySort ps = polys[i];

				int err = pDoc->db->Read(ps.id, po);
				assert(err == 0);
				GeoDB::SpatialObj* spatialObj = (GeoDB::SpatialObj*)po.Lock();
				TigerDB::Polygon* poly = (TigerDB::Polygon *)spatialObj;
				CBrush* brush;
				if ((brush = this->GetBrush(poly->userCode)) != 0)
				{
					XY_t cen = poly->getCentroid();
					int nPts = GeoDB::Poly::getPts(po, this->pts);
					std::string name = poly->GetName();
					if (poly->getArea() < 0.0)
						brush = &this->isleBrush;

					pDC->SelectObject(brush);
					if (doThining)
						nPts = TrendLine(this->pts, nPts, this->tDist);
					DrawPolygon(*this->mapWin, pDC, this->pts, nPts);
					XY_t pt;
					CPoint cPt;
					this->mapWin->Forward(&pt, cen);
					cPt.x = (int)pt.x;
					cPt.y = (int)pt.y;

					if (!name.empty() && (name != "Hydro" && name != "Island"))
					{
						CString str(name.c_str());
						CFont* def_font = pDC->SelectObject(&this->font);
						pDC->TextOut(cPt.x, cPt.y, str);
						pDC->SelectObject(def_font);
					}
				}
				po.Unlock();
			}
		}

		GeoDB::searchClasses_t objClasses = this->layerDlg->objClasses;
		if (objClasses.test(DB_POLY))
			objClasses.reset(DB_POLY);

		pDoc->db->InitSearch(&ss, range, objClasses);
		while (pDoc->db->getNext(&ss, &dbo) == 0)
		{
			/*if (frame->OnAbort())
				break;*/
			GeoDB::SpatialObj* spatialObj = (GeoDB::SpatialObj*)dbo.Lock();
			DbObject::ClassCode code = spatialObj->getClassCode();
			GeoDB::SpatialClass sc = spatialObj->IsA();
			switch (sc)
			{
				case GeoDB::POINT:
				{
					if (code == DB_POINT && this->layerDlg->doGNISPoints)  // Only display Points for now
					{
						TigerDB::GNISFeature* point = (TigerDB::GNISFeature*)spatialObj;
						XY_t pt;
						CPoint cPt;

						int code = point->userCode;

						if (!drawGNISFeature(code))
							break;

						this->mapWin->Forward(&pt, point->getPt());
						cPt.x = (int)pt.x;
						cPt.y = (int)pt.y;
						std::string name = point->GetName();
						CString str(name.c_str());
						CFont *def_font = pDC->SelectObject(&this->font);
						pDC->TextOut(cPt.x, cPt.y, str);
						pDC->SelectObject(def_font);
						BOOL b = pDC->Ellipse(cPt.x-2, cPt.y-2, cPt.x + 2, cPt.y + 2);
					}
					break;
				}

				case GeoDB::AREA:
				{
					assert(false);
					break;
				}

				case GeoDB::LINE:
				{
					nLines++;
					TigerDB::Chain* line = (TigerDB::Chain*)spatialObj;
					ASSERT(line != 0);
					CPen* pen;
					if ((pen = this->GetPen(line->userCode)) != 0)
					{
						int nPts = (int)line->getNumPts();
						line->Get(this->pts);
						/*if (pen != lastPen)  Disable - this caused a bug in symbology
						{
							pDC->SelectObject(pen);
							lastPen = pen;
						}*/
						pDC->SelectObject(pen);
						if (doThining)
							nPts = TrendLine(this->pts, nPts, this->tDist);
						DrawLine(*this->mapWin, pDC, this->pts, nPts);
						pDC->SelectObject(oldPen);
						
					}
				}
			}
			dbo.Unlock();
		}
		if (oldPen != 0)
			pDC->SelectObject(oldPen);
		//	app->LoadStandardCursor( IDC_ARROW );
	}

	SetCursor(cursor);
}

void CMapViewSDView::DoPan(double horizontal, double vertical)
{
	if (this->mapWin != 0)
	{
		double pan_factor = (double)(100 - this->pan_overlap) / 100.0;
		XY_t dispPt;

		dispPt.x = horizontal * pan_factor;
		dispPt.y = vertical * pan_factor;

		this->mapWin->PanByDisplay(dispPt);
		this->Invalidate();
	}
}

void CMapViewSDView::OnPanDown()
{
	this->DoPan(0.0, -1.0);
}

void CMapViewSDView::OnPanLeft()
{
	this->DoPan(-1.0, 0.0);
}

void CMapViewSDView::OnPanRight()
{
	this->DoPan(1.0, 0.0);
}

void CMapViewSDView::OnPanUp()
{
	this->DoPan(0.0, 1.0);
}

void CMapViewSDView::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (this->mapWin != 0)
	{
		this->pt = point;
		this->doWindow = TRUE;
		this->rect.SetRectEmpty();
	}

	CView::OnLButtonDown(nFlags, point);
}

const int PICK_TOL = 3;

void CMapViewSDView::OnLButtonUp(UINT nFlags, CPoint point)
{
	CView::OnLButtonUp(nFlags, point);

	if (this->doWindow)
	{
		XY_t pt0;
		int xDiff,
			yDiff;

		pt0.x = (double)this->pt.x;
		pt0.y = (double)this->pt.y;
		this->mapWin->Reverse(&pt0, pt0);

		if ((xDiff = point.x - this->pt.x) < 0)
			xDiff = -xDiff;

		if ((yDiff = point.y - this->pt.y) < 0)
			yDiff = -yDiff;

		if (xDiff <= PICK_TOL && yDiff <= PICK_TOL)
		{
#ifdef SAVE_FOR_NOW
			if (this->mapProj)
			{
				this->mapProj->Set(pt0.x, pt0.y);
				this->mapProj->Forward(&pt0, pt0);
			}
#endif
			this->mapWin->Set(pt0);
		}
		else
		{
			Range2D range;

			range.Add(pt0);

			pt0.x = (double)point.x;
			pt0.y = (double)point.y;
			this->mapWin->Reverse(&pt0, pt0);
			range.Add(pt0);

#ifdef SAVE_FOR_NOW  
			if (this->mapProj)
			{
				XY_t ll,
					ur,
					center;

				range.Corners(&ll, &ur);
				range.Center(&center);
				this->mapProj->Set(center.x, center.y);

				this->mapProj->Forward(&ll, ll);
				this->mapProj->Forward(&ur, ur);
				range.Init(ll, ur);
			}
#endif
			this->mapWin->Set(range);
		}

		this->doWindow = FALSE;
		this->Invalidate();
	}
}

void CMapViewSDView::OnRButtonDown(UINT nFlags, CPoint point)
{
	if (this->mapWin != 0)
	{
		this->doPick = TRUE;
		this->pt = point;
		this->rect.SetRectEmpty();

		if (this->doTest)
		{
			XY_t pt0;

			pt0.x = (double)point.x;
			pt0.y = (double)point.y;
			this->mapWin->Reverse(&this->pts[0], pt0);
		}
	}

	CView::OnRButtonDown(nFlags, point);
}

void CMapViewSDView::OnRButtonUp(UINT nFlags, CPoint point)
{
	XY_t pt0;
	CMapViewSDDoc* doc = GetDocument();

	if (this->doTest)
	{
		LineSeg2D lSeg;

		pt0.x = (double)point.x;
		pt0.y = (double)point.y;
		this->mapWin->Reverse(&pt0, pt0);

		ASSERT(doc->db != 0);
		if (doc->db->IsOpen())
		{
			DbSearchByLSeg so(*doc->db);
			DbSearch::Found fo;
			lSeg.Init(this->pts[0], pt0);

			so.Init(lSeg, this->layerDlg->objClasses);
			if (so.FindBest(&fo) == 0)
			{
			}
		}
	}
	else if (this->doPick)
	{
		Range2D range;

		CMainFrame* frame = (CMainFrame*)AfxGetApp()->m_pMainWnd;

		pt0.x = (double)this->pt.x;
		pt0.y = (double)this->pt.y;
		this->mapWin->Reverse(&pt0, pt0);
		range.Add(pt0);

		ASSERT(doc->db != 0);
		if (doc->db->IsOpen())
		{
			CDC* dc = GetDC();
			HCURSOR cursor = SetCursor(LoadCursor(0, IDC_WAIT));
			ObjHandle dbo;
			GeoDB::Search ss;

			// Note - testing different search methods
			//doc->db->Init(range, &ss);
			/*if (doc->db->GetNext(&ss, &dbo) == 0)*/
			DbSearchByPt so(*doc->db);
			//DbSearchByRange so(*doc->db);
			DbSearch::Found fo;

			//so.Init(range);
			so.Init(pt0, this->sDist, this->layerDlg->objClasses, this);
			if (so.FindBest(&fo) == 0)/**/
			{
				GeoDB::SpatialObj* sObj = (GeoDB::SpatialObj*)fo.handle.Lock();
				GeoDB::SpatialClass sc = sObj->IsA();
				switch (sc)
				{
				case GeoDB::POINT:
				{
					if (sObj->getClassCode() == DB_POINT)
					{
						TigerDB::GNISFeature* feat = (TigerDB::GNISFeature*)sObj;
						DisplayInfo(feat);
					}
					break;
				}
				case GeoDB::AREA:
				{
					TigerDB::Polygon* poly = (TigerDB::Polygon*)sObj;
					DisplayInfo(poly);
					break;
				}
				case GeoDB::LINE:
				{
					TigerDB::Chain* line = (TigerDB::Chain*)sObj;
					ASSERT(line != 0);
					CPen* pen;
					int code = line->userCode/*GetCode()*/;

					if ((pen = &this->hPen/*this->GetPen(code)*/) != 0)
					{
						//pen = &this->hPen;
						int nPts = (int)line->getNumPts();
						line->Get(this->pts);

						CPen* oldPen = dc->SelectObject(pen);
						int old_rop2 = dc->SetROP2(R2_XORPEN);

						if (this->doThining)
							nPts = TrendLine(this->pts, nPts, this->tDist);
						DrawLine(*this->mapWin, dc, this->pts, nPts, true);
						DisplayInfo(line);

#if defined(DO_SHORT_PATH)
						if (this->doShortPath)
						{
							double distSq;
							XY_t tempPt;
							int dir;

							distSq = fo.pt.DistSqr(this->pts[0]);
							if (distSq < fo.pt.DistSqr(this->pts[nPts - 1]))
							{
								tempPt = this->pts[0];
								dir = -1;
							}
							else
							{
								tempPt = this->pts[nPts - 1];
								dir = 1;
							}

							if (++this->pickCount == 1)
							{
								this->startId = line->dbAddress();
								this->startPt = tempPt;
								this->startDir = dir;
								this->startDist = line->Length();
								frame->m_wndStatusBar.SetPaneText(0, _T("ShortPath: pick the second edge by right-clicking"));
							}
							else if (this->pickCount == 2)
							{
								ShortPath sPath;
								ObjHandle handle;
								double dist;
								int nIds;

								frame->m_wndStatusBar.SetPaneText(0, _T("ShortPath: calculating..."));

								int err = doc->db->Read(this->startId, handle);
								assert(err == 0);
								line = (TigerDB::Chain*)handle.Lock();
								XY_t sPt, ePt;
								line->getNodes(&sPt, &ePt);
								double length = line->Length();
								handle.Unlock();
								double d1 = this->pts[0].DistSqr(sPt),
											 d2 = this->pts[0].DistSqr(ePt);
								if (d1 < d2)
									dir = 1;
								else
									dir = 0;
								sPath.Init(handle, fo.handle, 0, this->startPt);
								sPath.putEdge(handle, dir, length);
	
								ShortPath::filter_t f1,
									f2,
									f3;
								std::vector<long> edgeIds;

								f2.push_back(TigerDB::ROAD_PrimaryLimitedAccess);		// Need a UI for this (rather than hard-code)
								f2.push_back(TigerDB::ROAD_PrimaryUnlimitedAccess);
								f2.push_back(TigerDB::ROAD_SecondaryAndConnecting);
								f3.push_back(TigerDB::ROAD_LocalNeighborhoodAndRural);
								nIds = sPath.Find(*doc->db, f1, f2, f3, edgeIds, &dist);
								{
									for (int i = 0; i < edgeIds.size(); i++)
									{
										DbObject::Id id = edgeIds[i];
										if (id < 0)
											id = -id;
										err = doc->db->Read(id, handle);
										line = (TigerDB::Chain*)handle.Lock();
										nPts = (int)line->getNumPts();
										line->Get(this->pts);
										DrawLine(*this->mapWin, dc, this->pts, nPts);
										handle.Unlock();
									}
								}

								this->pickCount = 0;
								frame->m_wndStatusBar.SetPaneText(0, _T("ShortPath: pick the first edge by right-clicking"));
							}
						}
#endif
						dc->SelectObject(oldPen);
						dc->SetROP2(old_rop2);
					}
					break;
					}
				}

				fo.handle.Unlock();
			}
			SetCursor(cursor);
			ReleaseDC(dc);
		}
	}

	this->doPick = FALSE;
	CView::OnRButtonUp(nFlags, point);
}

void CMapViewSDView::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	if (doWindow || doPick)
	{
		CDC* dc = GetDC();

		this->brush.Attach(GetStockObject(NULL_BRUSH));

		CPen* old_pen = (CPen*)dc->SelectStockObject(WHITE_PEN /*&this->pen*/);
		CBrush* old_brush = dc->SelectObject(&this->brush);
		int old_rop2 = dc->SetROP2(R2_XORPEN);

		//	int dx = abs( this->pt.x - point.x);
		//	int dy = abs( this->pt.y - point.y);
		if (!this->rect.IsRectEmpty())
			dc->Rectangle(this->rect);

		this->rect.SetRect(this->pt.x, this->pt.y, point.x, point.y);
		this->rect.NormalizeRect();

		dc->Rectangle(this->rect);

		dc->SelectObject(old_pen);
		dc->SelectObject(old_brush);
		dc->SetROP2(old_rop2);
		this->brush.Detach();

		ReleaseDC(dc);
	}

	CView::OnMouseMove(nFlags, point);
}

void CMapViewSDView::DisplayInfo(TigerDB::Chain* line)
{
	if (this->doInfo)
	{
		TCHAR buffer[80];
		TigerDB::Name name;
		_stprintf_s(buffer, _T("%ld (%ld)"), line->userId, line->dbAddress());
		this->lineDlg->m_id = buffer;
		int nNames = line->GetNumNames();

		buffer[0] = _T('\0');
		if (nNames > 0)
		{
			for (int i = 0; i < nNames; i++)
			{
				line->GetName(&name, i);
				if (i > 0)
					_tcscat_s(buffer, _T("|"));

				if (::strlen(name.prefix) > 0)
				{
					_tcscat_s(buffer, TString(name.prefix));
					_tcscat_s(buffer, _T(" "));
				}

				if (::strlen(name.name) > 0)
				{
					_tcscat_s(buffer, TString(name.name));
				}
				if (::strlen(name.type) > 0)
				{
					_tcscat_s(buffer, _T(" "));
					_tcscat_s(buffer, TString(name.type));
				}
				if (::strlen(name.suffix) > 0)
				{
					_tcscat_s(buffer, _T(" "));
					_tcscat_s(buffer, TString(name.suffix));
				}
			}
		}

		this->lineDlg->m_name = buffer;
		this->lineDlg->m_type = "LINE: ";
		this->lineDlg->m_type += LineStr(line->userCode);
		this->lineDlg->UpdateData(FALSE);
	}
}


void CMapViewSDView::DisplayInfo(TigerDB::Polygon* poly)
{
	if (!this->doInfo)
		return;

		char /*TCHAR*/ buffer[80];
		sprintf(buffer, "%ld", poly->dbAddress());
		this->lineDlg->m_id = buffer;

		std::string &name = poly->GetName();
		this->lineDlg->m_name = name.c_str();
		const char* code = LineStr(poly->userCode);
		sprintf(buffer, "POLY: %s", code);
		this->lineDlg->m_type = buffer;
		this->lineDlg->UpdateData(FALSE);
}

void CMapViewSDView::DisplayInfo(TigerDB::GNISFeature* feature)
{
	if (!this->doInfo)
		return;

	char /*TCHAR*/ buffer[80];
	sprintf(buffer, "%ld", feature->dbAddress());
	this->lineDlg->m_id = buffer;

	std::string& name = feature->GetName();
	this->lineDlg->m_name = name.c_str();

	const char* code = FeatureStr(feature->userCode);
	sprintf(buffer, "POINT: %s", code);
	this->lineDlg->m_type = buffer;
	this->lineDlg->UpdateData(FALSE);
}

// CMapViewSDView printing


void CMapViewSDView::OnFilePrintPreview()
{
#ifndef SHARED_HANDLERS
	AFXPrintPreview(this);
#endif
}

BOOL CMapViewSDView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CMapViewSDView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CMapViewSDView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}
/*
void CMapViewSDView::OnRButtonUp(UINT , CPoint point)
{
	ClientToScreen(&point);
	OnContextMenu(this, point);
}
*/
void CMapViewSDView::OnContextMenu(CWnd* /* pWnd */, CPoint point)
{
#ifndef SHARED_HANDLERS
	// theApp.GetContextMenuManager()->ShowPopupMenu(IDR_POPUP_EDIT, point.x, point.y, this, TRUE); Don't want this to display 12/6/23
#endif
}


// CMapViewSDView diagnostics

#ifdef _DEBUG
void CMapViewSDView::AssertValid() const
{
	CView::AssertValid();
}

void CMapViewSDView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMapViewSDDoc* CMapViewSDView::GetDocument() const // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMapViewSDDoc)));
	return (CMapViewSDDoc*)m_pDocument;
}
#endif //_DEBUG


// CMapViewSDView message handlers

void CMapViewSDView::OnZoomIn()
{
	if (this->mapWin != 0)
	{
		this->mapWin->ScaleByFactor(this->zoom_factor);
		this->Invalidate();
	}
}

void CMapViewSDView::OnZoomOut()
{
	if (this->mapWin != 0)
	{
		this->mapWin->ScaleByFactor(1.0 / this->zoom_factor);
		this->Invalidate();
	}
}

void CMapViewSDView::OnMapLayers()
{
	if (this->layerDlg->DoModal() == IDOK)
	{
		this->Invalidate();
	}
}

void CMapViewSDView::OnUpdateMapLayers(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(this->mapWin != 0);
}

void CMapViewSDView::OnLineInfo()
{
	this->doInfo = !this->doInfo;
	if (doInfo)
		this->lineDlg->ShowWindow(SW_NORMAL);
	else
		this->lineDlg->ShowWindow(SW_HIDE);
}

void CMapViewSDView::OnUpdateLineInfo(CCmdUI* pCmdUI)
{
	if (this->mapWin != 0)
	{
		pCmdUI->SetCheck(this->doInfo);
	}
	else
		pCmdUI->Enable(FALSE);
}

void CMapViewSDView::OnMapProj()
{
	MapPDIAL dialog(this);

	dialog.m_projNum = this->doProj;
	if (dialog.DoModal() == IDOK)
	{
		if (dialog.m_projNum != this->doProj)
		{
			Range2D range;
			this->mapWin->GetRange(&range);

			this->doProj = dialog.m_projNum;
			if (this->doProj != 0)
			{
				this->mapProj = this->mapProjs[this->doProj - 1];
				this->mapWin->Set(this->mapProj);
			}
			else
				this->mapWin->Set(0);
			this->mapWin->Set(range);
			this->Invalidate();
		}
	}
}

void CMapViewSDView::OnThinPts()
{
	ThinDlg dlg(this);

	dlg.m_checked = this->doThining;
	dlg.m_value.Format(_T("%f"), this->tDist);
	if (dlg.DoModal() == IDOK)
	{
		double dist = ::atof(TString(dlg.m_value));
		BOOL doInvalid = FALSE;

		if (dist != this->tDist)
		{
			doInvalid = TRUE;
			this->tDist = dist;
		}

		if (this->doThining != dlg.m_checked)
		{
			doInvalid = TRUE;
			this->doThining = dlg.m_checked;
		}

		if (doInvalid)
			this->Invalidate();
	}
}

void CMapViewSDView::OnSearchUserid()
{
	SearchUserID searchDlg;
	INT_PTR retVal = searchDlg.DoModal();
	ObjHandle oh;

	if (retVal == IDOK)
	{
		int err = -1;
		CMapViewSDDoc* pDoc = GetDocument();
		if (!searchDlg.m_UserIDStr.IsEmpty())
		{
			DbObject::Id key = atoi(TString(searchDlg.m_UserIDStr));
			GeoDB::Edge::Hash dbHash;
			dbHash.id = key;

			err = pDoc->db->dacSearch(DB_EDGE, &dbHash, oh);
		}
		else if (!searchDlg.m_DatabaseIDStr.IsEmpty())
		{
			DbObject::Id key = atoi(TString(searchDlg.m_DatabaseIDStr));

			err = pDoc->db->Read(key, oh);
		}
		if (err == 0)
		{
			TigerDB::Chain* line = (TigerDB::Chain*)oh.Lock();
			DisplayInfo(line);
			const Range2D& range = line->getMBR();
			oh.Unlock();
			this->mapWin->Set(range);
			this->Invalidate();
		}
	}

	bool test = true;
}

bool CMapViewSDView::drawGNISFeature(int code)
{
	bool drawFeature = false;

	switch (code)
	{
	case TigerDB::GNIS_Summit:
	case TigerDB::GNIS_Range:
	case TigerDB::GNIS_Flat:
	case TigerDB::GNIS_Plain:
	case TigerDB::GNIS_Ridge:
	case TigerDB::GNIS_Swamp:
	case TigerDB::GNIS_Valley:
	case TigerDB::GNIS_Woods:
	case TigerDB::GNIS_Gap:
	case TigerDB::GNIS_Basin:
	case TigerDB::GNIS_Bench:
		if (this->layerDlg->doLandForm)
			drawFeature = true;
		break;

	case TigerDB::GNIS_Bay:
	case TigerDB::GNIS_Sea:
	case TigerDB::GNIS_Beach:
	case TigerDB::GNIS_Canal:
	case TigerDB::GNIS_Channel:
	case TigerDB::GNIS_Cape:
	case TigerDB::GNIS_Bar:
	case TigerDB::GNIS_Isthmus:
		if (this->layerDlg->doCoastal)
			drawFeature = true;
		break;

	case TigerDB::GNIS_Arch:
	case TigerDB::GNIS_Area:
	case TigerDB::GNIS_Arroyo:
	case TigerDB::GNIS_Bend:
	case TigerDB::GNIS_Cliff:
	case TigerDB::GNIS_Crater:
	case TigerDB::GNIS_Crossing:
	case TigerDB::GNIS_Slope:
	case TigerDB::GNIS_Gut:
		if (this->layerDlg->doTopographic)
			drawFeature = true;
		break;

	case TigerDB::GNIS_Census:
	case TigerDB::GNIS_Civil:
	case TigerDB::GNIS_PopulatedPlace:
		if (this->layerDlg->doCensus)
			drawFeature = true;
		break;

	case TigerDB::GNIS_Glacier:
	case TigerDB::GNIS_Island:
	case TigerDB::GNIS_Lake:
	case TigerDB::GNIS_Rapids:
	case TigerDB::GNIS_Reservoir:
	case TigerDB::GNIS_Falls:
	case TigerDB::GNIS_Spring:
	case TigerDB::GNIS_Stream:
		if (this->layerDlg->doHydrology)
			drawFeature = true;
		break;

	case TigerDB::GNIS_Levee:
	case TigerDB::GNIS_Military:
		if (this->layerDlg->doCultural)
			drawFeature = true;
		break;

	case TigerDB::GNIS_Pillar:
	case TigerDB::GNIS_Lava:
		if (this->layerDlg->doOtherNames)
			drawFeature = true;
		break;

	default:
		break;
	}
	return drawFeature;
}

static const char* LineStr(int code)
{
	const char* str;

	switch (code)
	{
	default:
		str = "Feature unknown";
		break;

	case TigerDB::NotClassified:
		str = "Feature not classified";
		break;

	case TigerDB::ROAD_MajorCategoryUnknown:
		str = "Road: categories unknown";
		break;

	case TigerDB::ROAD_PrimaryLimitedAccess:
		str = "Primary Road: Interstate highway";
		break;

	case TigerDB::ROAD_PrimaryUnlimitedAccess:
		str = "Primary Road: US/State highway";
		break;

	case TigerDB::ROAD_SecondaryAndConnecting:
		str = "Secondary Road: State/county highway";
		break;

	case TigerDB::ROAD_LocalNeighborhoodAndRural:
		str = "Local Road: city street/rural road";
		break;

	case TigerDB::ROAD_VehicularTrail:
		str = "Trail";
		break;

	case TigerDB::ROAD_AccessRamp:
		str = "Access ramp";
		break;

	case TigerDB::ROAD_SpecialCharacteristics:
	case TigerDB::ROAD_Cul_de_sac:
	case TigerDB::ROAD_TrafficCircle:
	case TigerDB::ROAD_OtherThoroughfare:
	case TigerDB::ROAD_ServiceDrive:
		str = "Road: other";
		break;

	case TigerDB::ROAD_FerryCrossing:
		str = "Ferry crossing";
		break;

	case TigerDB::RR_MajorCategoryUnknown:
	case TigerDB::RR_MainLine:
	case TigerDB::RR_Spur:
		str = "Railroad";
		break;

	case TigerDB::RR_Yard:
	case TigerDB::RR_FerryCrossing:
	case TigerDB::RR_OtherThoroughfare:
		str = "Railroad: other";
		break;

	case TigerDB::MGT_CategoryUnknown:
		str = "Ground transportation Unknown";
		break;
	case TigerDB::MGT_Pipeline:
		str = "Pipeline";
		break;
	case TigerDB::MGT_PowerLine:
		str = "Power Line";
		break;
	case TigerDB::MGT_Other:
		str = "Other Ground transportation";
		break;
	case TigerDB::MGT_AerialTramway:
		str = "Aerial Tramway";
		break;
	case TigerDB::MGT_PierDock:
		str = "Pier or Dock";
		break;

	case TigerDB::LM_CategoryUnknown:
	case TigerDB::LM_MilitaryInstallation:
	case TigerDB::LM_MultihouseholdOrTransientQuarters:
	case TigerDB::LM_ApartmentBuildingOrBoardingHouse:
	case TigerDB::LM_MobileHomePark:
	case TigerDB::LM_Marina:
	case TigerDB::LM_CrewOfVessel:
	case TigerDB::LM_HotelOrMotel:
	case TigerDB::LM_Campground:
	case TigerDB::LM_ShelterOrMission:
	case TigerDB::LM_CustodialFacility:
	case TigerDB::LM_Hospital:
	case TigerDB::LM_HalfwayHouse:
	case TigerDB::LM_NursingHome:
	case TigerDB::LM_CountyHome:
	case TigerDB::LM_Orphanage:
	case TigerDB::LM_Jail:
	case TigerDB::LM_FederalOrStatePrison:
	case TigerDB::LM_EducationalOrReligiousInstitution:
	case TigerDB::LM_SororityOrFraternity:
	case TigerDB::LM_ConventOrMonastery:
	case TigerDB::LM_EducationalInstitution:
	case TigerDB::LM_ReligiousInstitution:
	case TigerDB::LM_TransportationTerminal:
	case TigerDB::LM_Airport:
	case TigerDB::LM_TrainStation:
	case TigerDB::LM_BusTerminal:
	case TigerDB::LM_MarineTerminal:
	case TigerDB::LM_SeaplaneAnchorage:
	case TigerDB::LM_Employmentcenter:
	case TigerDB::LM_ShoppingOrRetailCenter:
	case TigerDB::LM_IndustrialBuildingOrPark:
	case TigerDB::LM_OfficebuildingOrPark:
	case TigerDB::LM_AmusementCenter:
	case TigerDB::LM_GovernmentCenter:
	case TigerDB::LM_OtherEmploymentCenter:
	case TigerDB::LM_Tower:
	case TigerDB::LM_LookoutTower:
	case TigerDB::LM_OpenSpace:
	case TigerDB::LM_GolfCourse:
	case TigerDB::LM_Cemetery:
	case TigerDB::LM_NationalParkService:
	case TigerDB::LM_NationalForestOrOther:
	case TigerDB::LM_StateOrLocalPark_Forest:
	case TigerDB::LM_SpecialPurpose:
	case TigerDB::LM_Museum:
	case TigerDB::LM_CommunityCenter:
	case TigerDB::LM_Library:
	case TigerDB::LM_AirportIntermodelTransportationHub:
	case TigerDB::LM_AirportStatisticalRepresentation:
	case TigerDB::LM_ParkAndRide:
	case TigerDB::LM_ConventionCenter:
	case TigerDB::LM_TransmissionTower:
	case TigerDB::LM_WaterTower:
	case TigerDB::LM_LighthouseBeacon:
	case TigerDB::LM_Tank:
	case TigerDB::LM_WindmillFarm:
	case TigerDB::LM_SolarFarm:
	case TigerDB::LM_MonumentMemorial:
	case TigerDB::LM_SurveyBoundaryMemorial:
	case TigerDB::LM_Zoo:
	case TigerDB::LM_VineyardWineryOrchard:
	case TigerDB::LM_LandfillDump:
	case TigerDB::LM_InternalUSCensusBureau:
		str = "Land Mark features";
		break;

	case TigerDB::PF_CategoryUnknown:
	case TigerDB::PF_Fenceline:
	case TigerDB::PF_TopographicFeature:
	case TigerDB::PF_RidgeLine:
	case TigerDB::PF_MountainPeak:
	case TigerDB::PF_Levee:
	case TigerDB::PF_MarshSwamp:
	case TigerDB::PF_QuarryMine:
	case TigerDB::PF_Dam:
		str = "Physical features";
		break;

	case TigerDB::NVF_BoundaryClassificationUnknown:
	case TigerDB::NVF_LegalOrAdministrativeBoundary:
		str = "Jurisdictional boundary";
		break;

	case TigerDB::NVF_ClosureExtension:
	case TigerDB::NVF_SeparationLine:
	case TigerDB::NVF_Centerline:
		str = "Closure extension";
		break;

	case TigerDB::NVF_PropertyLine:
		str = "Property line";
		break;

	case TigerDB::NVF_ZIPCodeBoundary:
		str = "ZIP Code Boundary";
		break;

	case TigerDB::NVF_StatisticalBoundary:
		str = "Statistical Boundary";
		break;

	case TigerDB::NVF_OtherTabulationBoundary:
		str = "Other Tabulation Boundary";
		break;

	case TigerDB::HYDRO_WaterAreaDefinitionBoundary:
		str = "Water Area Definition Boundary";
		break;

	case TigerDB::HYDRO_USGSClosureLine:
		str = "USGS Closure line";
		break;

	case TigerDB::HYDRO_CensusWaterCenterLine:
		str = "Census Water Centerline";
		break;

	case TigerDB::HYDRO_ArtificialPath:
		str = "Artificial Path";
		break;

	case TigerDB::HYDRO_CensusWaterBoundary3Mile:
		str = "3 Mile Water Boundary";
		break;
	case TigerDB::HYDRO_CensusWaterBoundary12Mile:
		str = "12 Mile Water Boundary";
		break;

	case TigerDB::HYDRO_ClassificationUnknown:
	case TigerDB::HYDRO_PerennialShoreline:
	case TigerDB::HYDRO_IntermittentShoreline:
		str = "Shoreline";
		break;

	case TigerDB::HYDRO_PerennialStream:
	case TigerDB::HYDRO_IntermittentStream:
		str = "Streams";
		break;

	case TigerDB::HYDRO_PerennialCanalDitchOrAqueduct:
	case TigerDB::HYDRO_IntermittentCanalDitchOrAqueduct:
	case TigerDB::HYDRO_PerennialLakeOrPond:
	case TigerDB::HYDRO_IntermittentLakeOrPond:
	case TigerDB::HYDRO_PerennialReservoir:
	case TigerDB::HYDRO_IntermittentReservoir:
	case TigerDB::HYDRO_BayEstuaryGulfOrSound:
	case TigerDB::HYDRO_SeaOrOcean:
	case TigerDB::HYDRO_GravelPitOrQuarry:
	case TigerDB::HYDRO_Glacier:
		str = "Hydrography";
		break;
	}

	return(str);
}

static const char* FeatureStr(int code)
{
	const char* str;
	switch (code)
	{
	case TigerDB::GNIS_Summit:
		str = "Summit";
		break;
	case TigerDB::GNIS_Range:
		str = "Range";
		break;
	case TigerDB::GNIS_Flat:
		str = "Flat";
		break;
	case TigerDB::GNIS_Plain:
		str = "Plain";
		break;
	case TigerDB::GNIS_Ridge:
		str = "Ridge";
		break;
	case TigerDB::GNIS_Swamp:
		str = "Swamp";
		break;
	case TigerDB::GNIS_Valley:
		str = "Valley";
		break;
	case TigerDB::GNIS_Woods:
		str = "Woods";
		break;
	case TigerDB::GNIS_Gap:
		str = "Gap";
		break;
	case TigerDB::GNIS_Basin:
		str = "Basin";
		break;
	case TigerDB::GNIS_Bench:
		str = "Bench";
		break;

	case TigerDB::GNIS_Bay:
		str = "Bay";
		break;
	case TigerDB::GNIS_Sea:
		str = "Sea";
		break;
	case TigerDB::GNIS_Beach:
		str = "Beach";
		break;
	case TigerDB::GNIS_Canal:
		str = "Canal";
		break;
	case TigerDB::GNIS_Channel:
		str = "Channel";
		break;
	case TigerDB::GNIS_Cape:
		str = "Cape";
		break;
	case TigerDB::GNIS_Bar:
		str = "Bar";
		break;
	case TigerDB::GNIS_Isthmus:
		str = "Isthmus";
		break;

	case TigerDB::GNIS_Arch:
		str = "Arch";
		break;
	case TigerDB::GNIS_Area:
		str = "Area";
		break;
	case TigerDB::GNIS_Arroyo:
		str = "Arroyo";
		break;
	case TigerDB::GNIS_Bend:
		str = "Bend";
		break;
	case TigerDB::GNIS_Cliff:
		str = "Cliff";
		break;
	case TigerDB::GNIS_Crater:
		str = "Crater";
		break;
	case TigerDB::GNIS_Crossing:
		str = "Crossing";
		break;
	case TigerDB::GNIS_Slope:
		str = "Slope";
		break;
	case TigerDB::GNIS_Gut:
		str = "Gut";
		break;

	case TigerDB::GNIS_Census:
		str = "Census";
		break;
	case TigerDB::GNIS_Civil:
		str = "Civil";
		break;
	case TigerDB::GNIS_PopulatedPlace:
		str = "Populated Place";
		break;

	case TigerDB::GNIS_Glacier:
		str = "Glacier";
		break;
	case TigerDB::GNIS_Island:
		str = "Island";
		break;
	case TigerDB::GNIS_Lake:
		str = "Lake";
		break;
	case TigerDB::GNIS_Rapids:
		str = "Rapids";
		break;
	case TigerDB::GNIS_Reservoir:
		str = "Reservoir";
		break;
	case TigerDB::GNIS_Falls:
		str = "Falls";
		break;
	case TigerDB::GNIS_Spring:
		str = "Spring";
		break;
	case TigerDB::GNIS_Stream:
		str = "Stream";
		break;
	case TigerDB::GNIS_Levee:
		str = "Levee";
		break;
	case TigerDB::GNIS_Military:
		str = "Military";
		break;

	case TigerDB::GNIS_Pillar:
		str = "Pillar";
		break;
	case TigerDB::GNIS_Lava:
		str = "Lava";
		break;

	default:
		str = "Unknown";
		break;
	}
	return str;
}


void CMapViewSDView::OnUpdateSearchUserid(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(this->mapWin != 0);
}


void CMapViewSDView::OnUpdateToolsShortpath(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(this->mapWin != 0);
	pCmdUI->SetCheck(this->doShortPath);

}


void CMapViewSDView::OnToolsShortpath()
{
	this->doShortPath = !this->doShortPath;
	CMainFrame* frame = (CMainFrame*)AfxGetApp()->m_pMainWnd;
	if (this->doShortPath)
		frame->m_wndStatusBar.SetPaneText(0, _T("ShortPath: pick the first edge by right-clicking"));
	else
		frame->m_wndStatusBar.SetPaneText(0, _T(""));
}


void CMapViewSDView::OnUpdateToolsThining(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(this->mapWin != 0);
}


void CMapViewSDView::OnToolsThining()
{
	ThinDlg dlg(this);

	dlg.m_checked = this->doThining;
	dlg.m_value.Format(_T("%f"), this->tDist);
	if (dlg.DoModal() == IDOK)
	{
		double dist = ::atof(TString(dlg.m_value));
		BOOL doInvalid = FALSE;

		if (dist != this->tDist)
		{
			doInvalid = TRUE;
			this->tDist = dist;
		}

		if (this->doThining != dlg.m_checked)
		{
			doInvalid = TRUE;
			this->doThining = dlg.m_checked;
		}

		if (doInvalid)
			this->Invalidate();
	}
}
